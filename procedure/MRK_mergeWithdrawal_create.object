#!/bin/sh

#
#
# History
#
# 10/14/2014 	sc
#	- TR11674 - HDP-2 project
#	- prevent merge if marker cross referenced in MGI_Relationship
#
# 12/12/2013	lec
#	- TR11515/high throughput part 2/allele stuff
#	- change call to ALL_insertAllele for recent schema changes
#
# 08/19/2010    lec
#       - TR10317; remove allele/cellline edits
#
# 12/09/2004	lec
#	- TR 5686
#
# 06/30/2004	lec
#	- TR 5998
#
# lec	08/26/2003
#	- TR 4708
#
# lec	05/09/2003
#	- TR 4587; move Marker Detail Clip over during merge
#
# lec	04/08/2002
#	- TR 3550; MRK_mergeWithdrawal; change call to ALL_insertAllele
#

cd `dirname $0` && . ./Configuration

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

DROP FUNCTION MRK_mergeWithdrawal(int,int,int,int,int,int);

CREATE OR REPLACE FUNCTION MRK_mergeWithdrawal (
v_oldKey int,
v_newKey int,
v_refKey int,
v_eventKey int,
v_eventReasonKey int,
v_addAsSynonym int DEFAULT 1
)
RETURNS VOID AS
\$\$

DECLARE
v_userKey int;
v_oldSymbol mrk_marker.symbol%TYPE;
v_oldName mrk_marker.name%TYPE;
v_newSymbol mrk_marker.symbol%TYPE;
v_newChr char(8)
v_modifiedByKey int;
v_part_categoryname mgi_relationship_category.name%TYPE;
v_org_categoryname mgi_relationship_category.name%TYPE;
v_withdrawnName mrk_marker.name%TYPE;
v_alleleOf int;
v_alleleSymbol all_allele.symbol%TYPE;
v_assigningRefKey int;
v_synTypeKey int;

BEGIN

--
-- This procedure will process a merge marker withdrawal.
-- A merge withdrawal is a withdrawal where both the "old" and "new"
-- markers already exist in the database.
--
-- A merge marker withdrawal requires:
--	a) the "old" marker key
--	b) the "new" marker key
--	c) the reference key
--	d) the event key
--	e) the event reason key
--	f) the "add as synonym" flag
--
--

IF v_oldKey = v_newKey
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Cannot Merge a Symbol into itself: %, %', v_oldKey, v_newKey;
	RETURN;
END IF;

v_modifiedByKey := _User_key from MGI_User where login = current_user;

select v_oldSymbol = symbol,
       v_oldName = name
from MRK_Marker where _Marker_key = v_oldKey
     and _Organism_key = 1
     and _Marker_Status_key in (1,3)

IF v_oldSymbol is null
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Invalid Old Symbol Key %', v_oldKey;
	RETURN;
END IF;

select v_newSymbol = symbol
from MRK_Marker where _Marker_key = v_newKey
     and _Organism_key = 1
     and _Marker_Status_key in (1,3)

IF v_newSymbol is null
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Invalid New Symbol Key %', v_newKey;
	RETURN;
END IF;

select distinct v_part_categoryname = c.name
from MGI_Relationship r, MGI_Relationship_Category c
where r._Category_key = c._Category_key
and r._Object_key_2 = v_oldKey

select distinct v_org_categoryname = c.name
from MGI_Relationship r, MGI_Relationship_Category c
where r._Category_key in (1001, 1002)
and r._Category_key = c._Category_key
and r._Object_key_1 = v_oldKey

/* Prevent the merge if the merge will result in a conflict in homology */
/* That is, if both the old and new symbol exist in distinct Orthology classes */
/* then the merge of the two symbols will result in a conflict */

IF EXISTS (select 1 from HMD_Homology_Marker where _Marker_key = v_oldKey) and
   EXISTS (select 1 from HMD_Homology_Marker where _Marker_key = v_newKey)
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Cannot Merge:  both Symbols contain Orthology associations.';
	RETURN;
END IF;

/* Prevent the merge if the a Marker Detail Clip exists for both symbols */

IF exists (select 1 from MRK_Notes where _Marker_key = v_oldKey) and
   exists (select 1 from MRK_Notes where _Marker_key = v_newKey)
THEN
        RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Cannot Merge:  both Symbols contain a Marker Detail Clip.';
        RETURN;
END IF;

/* Prevent the merge if a Participant MGI_Relationship exists for the old  symbol */
if exists (select 1 from MGI_Relationship where _Object_key_2 = v_oldKey)
THEN
        RAISE EXCEPTION E'\nMRK_mergeWithdrawal: \n\nCannot Merge: Old Symbol is a Participant in a MGI_Relationship:\n\n%n', v_part_categoryname;
        RETURN;
END IF;

/* Prevent the merge if a Organizer MGI_Relationship exists for the old symbol */
if exists (select 1 from MGI_Relationship where _Object_key_1 = v_oldKey and _Category_key in (1001, 1002))
THEN
        RAISE EXCEPTION E'\nMRK_mergeWithdrawal: \n\nCannot Merge: Old Symbol is an Organizer in a MGI_Relationship:\n\n%', v_org_categoryname;
        RETURN;
END IF;


if v_eventKey = 4
THEN
	select v_withdrawnName = "withdrawn, allele of " + v_newSymbol
	select v_alleleOf = 1
END IF;
else
THEN
	select v_withdrawnName = "withdrawn, = " + v_newSymbol
	select v_alleleOf = 0
END IF;

/* If new symbol has a chromosome of UN, update the new symbol's chromosome value */
/* with the old symbol chromosome value */

if (select chromosome from MRK_Marker where _Marker_key = v_newKey) = "UN"
THEN
	select v_newChr = chromosome from MRK_Marker where _Marker_key = v_oldKey
	update MRK_Marker set chromosome = v_newChr, _ModifiedBy_key = v_modifiedByKey, modification_date = getdate() where _Marker_key = v_newKey

	IF NOT FOUND
	THEN
		RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update new symbol's chromosome';
		RETURN;
	END IF;
END IF;

/* Update offset values of new symbol */

exec MRK_updateOffset v_oldKey, v_newKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update offset values';
	RETURN;
END IF;

/* Update MGD offset of old symbol */

update MRK_Offset set offset = -999.0 where _Marker_key = v_oldKey and source = 0

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update offset of old symbol';
	RETURN;
END IF;

/* Delete remaining offsets of old symbol */

delete MRK_Offset where _Marker_key = v_oldKey and source > 0

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not delete offsets of old symbol';
	RETURN;
END IF;

/* Update name/cytogenetic offset of old symbol */

update MRK_Marker 
set name = v_withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2, _ModifiedBy_key = v_modifiedByKey, modification_date = getdate()
where _Marker_key = v_oldKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update name of old symbol';
	RETURN;
END IF;

/* Merge potential duplicate wild type alleles of old and new symbols */
/* before converting oldsymbol alleles */

exec ALL_mergeWildTypes v_oldKey, v_newKey, v_oldSymbol, v_newSymbol

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not merge wild type alleles';
	RETURN;
END IF;

/* Convert Remaining Alleles */

exec ALL_convertAllele v_oldKey, v_oldSymbol, v_newSymbol, v_alleleOf

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not convert alleles';
	RETURN;
END IF;

if v_alleleOf = 1
THEN
	/* If no alleles exist for the old symbol, create a newSymbol<oldSymbol> allele */

	if not exists (select 1 from ALL_Allele where _Marker_key = v_oldKey)
	THEN
		select v_alleleSymbol = v_newSymbol + "<" + v_oldSymbol + ">"

		exec ALL_insertAllele v_newKey,v_refKey,v_alleleSymbol,0,v_oldName,null,null,null,null,
			-1,'Not Specified','Not Specified','Approved',v_oldSymbol

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not insert allele';
			RETURN;
		END IF;
	END IF;
END IF;

/* Update current symbols */

update MRK_Current set _Current_key = v_newKey where _Current_key = v_oldKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update current symbols';
	RETURN;
END IF;

/* Copy History records from old symbol to new symbol */

exec MRK_copyHistory v_oldKey, v_newKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not copy history records';
	RETURN;
END IF;

/* Insert history record for withdrawal */

exec MRK_insertHistory v_newKey, v_oldKey, v_refKey, v_eventKey, v_eventReasonKey, v_oldName

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not create history record';
	RETURN;
END IF;

/* Remove history records from old symbol */

delete from MRK_History where _Marker_key = v_oldKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not delete obsolete history records';
	RETURN;
END IF;

/* Insert withdrawn symbol into Synonym table */
/* Use assigning reference */
if v_addAsSynonym = 1
THEN
	select distinct v_assigningRefKey = _Refs_key from MRK_History_View
		where _Marker_key = v_newKey
		and history = v_oldSymbol
		and _Marker_Event_key = 1

	/* If oldSymbol is a Riken symbol (ends with 'Rik'), then synonym type = 'similar' */
	/* else synonym type = 'exact' */


	if charindex('Rik', v_oldSymbol) > 0
	THEN
	    select v_synTypeKey = _SynonymType_key from MGI_SynonymType 
		where _MGIType_key = 2 
		and _Organism_key = 1
		and synonymType = 'similar'
	END IF;
        else
	THEN
	    select v_synTypeKey = _SynonymType_key from MGI_SynonymType 
		where _MGIType_key = 2 
		and _Organism_key = 1
		and synonymType = 'exact'
        END IF;

	exec MGI_insertSynonym v_newKey, 2, v_synTypeKey, v_oldSymbol, v_assigningRefKey

	IF NOT FOUND
	THEN
		RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not add synonym';
		RETURN;
	END IF;
END IF;

/* Update keys from old key to new key */

exec MRK_updateKeys v_oldKey, v_newKey

IF NOT FOUND
THEN
	RAISE EXCEPTION E'\nMRK_mergeWithdrawal: Could not update keys';
	RETURN;
END IF;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION MRK_mergeWithdrawal(int,int,int,int,int,int) TO public;

COMMENT ON FUNCTION mgd.MRK_mergeWithdrawal(int, int,int,int,int,int) IS 'process a merge withdrawal';

EOSQL

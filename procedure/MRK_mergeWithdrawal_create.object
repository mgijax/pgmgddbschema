#!/bin/sh

#
#
# History
#
# 10/14/2014 	sc
#	- TR11674 - HDP-2 project
#	- prevent merge if marker cross referenced in MGI_Relationship
#
# 12/12/2013	lec
#	- TR11515/high throughput part 2/allele stuff
#	- change call to ALL_insertAllele for recent schema changes
#
# 08/19/2010    lec
#       - TR10317; remove allele/cellline edits
#
# 12/09/2004	lec
#	- TR 5686
#
# 06/30/2004	lec
#	- TR 5998
#
# lec	08/26/2003
#	- TR 4708
#
# lec	05/09/2003
#	- TR 4587; move Marker Detail Clip over during merge
#
# lec	04/08/2002
#	- TR 3550; MRK_mergeWithdrawal; change call to ALL_insertAllele
#

cd `dirname $0` && . ./Configuration

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

DROP FUNCTION MRK_mergeWithdrawal(int,int,int,int,int,int);

CREATE OR REPLACE FUNCTION MRK_mergeWithdrawal (
v_oldKey int,
v_newKey int,
v_refKey int,
v_eventKey int,
v_eventReasonKey int,
v_addAsSynonym int DEFAULT 1
)
RETURNS VOID AS
\$\$

DECLARE
v_userKey int;
v_oldSymbol mrk_marker.symbol%TYPE;
v_oldName mrk_marker.name%TYPE;
v_newSymbol mrk_marker.symbol%TYPE;
v_newChr char(8)
v_modifiedByKey int;
v_part_categoryname mgi_relationship_category.name%TYPE;
v_org_categoryname mgi_relationship_category.name%TYPE;
v_withdrawnName mrk_marker.name%TYPE;
v_alleleOf int;
v_alleleSymbol all_allele.symbol%TYPE;
v_assigningRefKey int;
v_synTypeKey int;

BEGIN

--
-- This procedure will process a merge marker withdrawal.
-- A merge withdrawal is a withdrawal where both the "old" and "new"
-- markers already exist in the database.
--
-- A merge marker withdrawal requires:
--	a) the "old" marker key
--	b) the "new" marker key
--	c) the reference key
--	d) the event key
--	e) the event reason key
--	f) the "add as synonym" flag
--
--

if v_oldKey = v_newKey
begin
	raiserror 99999 "Cannot Merge a Symbol into itself: %1!, %2!", v_oldKey, v_newKey
	rollback transaction
	return
end

v_modifiedByKey := _User_key from MGI_User where login = current_user;

select v_oldSymbol = symbol,
       v_oldName = name
from MRK_Marker where _Marker_key = v_oldKey
     and _Organism_key = 1
     and _Marker_Status_key in (1,3)

if v_oldSymbol is null
begin
	raiserror 99999 "Invalid Old Symbol Key %1!", v_oldKey
	rollback transaction
	return
end

select v_newSymbol = symbol
from MRK_Marker where _Marker_key = v_newKey
     and _Organism_key = 1
     and _Marker_Status_key in (1,3)

if v_newSymbol is null
begin
	raiserror 99999 "Invalid New Symbol Key %1!", v_newKey
	rollback transaction
	return
end

select distinct v_part_categoryname = c.name
from MGI_Relationship r, MGI_Relationship_Category c
where r._Category_key = c._Category_key
and r._Object_key_2 = v_oldKey

select distinct v_org_categoryname = c.name
from MGI_Relationship r, MGI_Relationship_Category c
where r._Category_key in (1001, 1002)
and r._Category_key = c._Category_key
and r._Object_key_1 = v_oldKey

/* Prevent the merge if the merge will result in a conflict in homology */
/* That is, if both the old and new symbol exist in distinct Orthology classes */
/* then the merge of the two symbols will result in a conflict */

if exists (select 1 from HMD_Homology_Marker where _Marker_key = v_oldKey) and
   exists (select 1 from HMD_Homology_Marker where _Marker_key = v_newKey)
begin
	raiserror 99999 "Cannot Merge:  both Symbols contain Orthology associations."
	rollback transaction
	return
end

/* Prevent the merge if the a Marker Detail Clip exists for both symbols */

if exists (select 1 from MRK_Notes where _Marker_key = v_oldKey) and
   exists (select 1 from MRK_Notes where _Marker_key = v_newKey)
begin
        raiserror 99999 "Cannot Merge:  both Symbols contain a Marker Detail Clip."
        rollback transaction
        return
end

/* Prevent the merge if a Participant MGI_Relationship exists for the old  symbol */
if exists (select 1 from MGI_Relationship where _Object_key_2 = v_oldKey)
begin
        raiserror 99999 "\n\nCannot Merge: Old Symbol is a Participant in a MGI_Relationship:\n\n%1!\n", v_part_categoryname
        rollback transaction
        return
end

/* Prevent the merge if a Organizer MGI_Relationship exists for the old symbol */
if exists (select 1 from MGI_Relationship where _Object_key_1 = v_oldKey and _Category_key in (1001, 1002))
begin
        raiserror 99999 "\n\nCannot Merge: Old Symbol is an Organizer in a MGI_Relationship:\n\n%1!\n", v_org_categoryname
        rollback transaction
        return
end


if v_eventKey = 4
begin
	select v_withdrawnName = "withdrawn, allele of " + v_newSymbol
	select v_alleleOf = 1
end
else
begin
	select v_withdrawnName = "withdrawn, = " + v_newSymbol
	select v_alleleOf = 0
end

/* If new symbol has a chromosome of UN, update the new symbol's chromosome value */
/* with the old symbol chromosome value */

if (select chromosome from MRK_Marker where _Marker_key = v_newKey) = "UN"
begin
	select v_newChr = chromosome from MRK_Marker where _Marker_key = v_oldKey
	update MRK_Marker set chromosome = v_newChr, _ModifiedBy_key = v_modifiedByKey, modification_date = getdate() where _Marker_key = v_newKey

	if @@error != 0
	begin
		raiserror 99999 "Could not update new symbol's chromosome in MRK_mergeWithdrawal"
		rollback transaction
		return
	end
end

/* Update offset values of new symbol */

exec MRK_updateOffset v_oldKey, v_newKey

if @@error != 0
begin
	raiserror 99999 "Could not update offset values in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Update MGD offset of old symbol */

update MRK_Offset set offset = -999.0 where _Marker_key = v_oldKey and source = 0

if @@error != 0
begin
	raiserror 99999 "Could not update offset of old symbol in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Delete remaining offsets of old symbol */

delete MRK_Offset where _Marker_key = v_oldKey and source > 0

if @@error != 0
begin
	raiserror 99999 "Could not delete offsets of old symbol in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Update name/cytogenetic offset of old symbol */

update MRK_Marker 
set name = v_withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2, _ModifiedBy_key = v_modifiedByKey, modification_date = getdate()
where _Marker_key = v_oldKey

if @@error != 0
begin
	raiserror 99999 "Could not update name of old symbol in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Merge potential duplicate wild type alleles of old and new symbols */
/* before converting oldsymbol alleles */

exec ALL_mergeWildTypes v_oldKey, v_newKey, v_oldSymbol, v_newSymbol

if @@error != 0
begin
	raiserror 99999 "Could not merge wild type alleles in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Convert Remaining Alleles */

exec ALL_convertAllele v_oldKey, v_oldSymbol, v_newSymbol, v_alleleOf

if @@error != 0
begin
	raiserror 99999 "Could not convert alleles in MRK_mergeWithdrawal"
	rollback transaction
	return
end

if v_alleleOf = 1
begin
	/* If no alleles exist for the old symbol, create a newSymbol<oldSymbol> allele */

	if not exists (select 1 from ALL_Allele where _Marker_key = v_oldKey)
	begin
		select v_alleleSymbol = v_newSymbol + "<" + v_oldSymbol + ">"

		exec ALL_insertAllele v_newKey,v_refKey,v_alleleSymbol,0,v_oldName,null,null,null,null,
			-1,'Not Specified','Not Specified','Approved',v_oldSymbol

		if @@error != 0
		begin
			raiserror 99999 "Could not insert allele in MRK_mergeWithdrawal"
			rollback transaction
			return
		end
	end
end

/* Update current symbols */

update MRK_Current set _Current_key = v_newKey where _Current_key = v_oldKey

if @@error != 0
begin
	raiserror 99999 "Could not update current symbols in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Copy History records from old symbol to new symbol */

exec MRK_copyHistory v_oldKey, v_newKey

if @@error != 0
begin
	raiserror 99999 "Could not copy history records in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Insert history record for withdrawal */

exec MRK_insertHistory v_newKey, v_oldKey, v_refKey, v_eventKey, v_eventReasonKey, v_oldName

if @@error != 0
begin
	raiserror 99999 "Could not create history record in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Remove history records from old symbol */

delete from MRK_History where _Marker_key = v_oldKey

if @@error != 0
begin
	raiserror 99999 "Could not delete obsolete history records in MRK_mergeWithdrawal"
	rollback transaction
	return
end

/* Insert withdrawn symbol into Synonym table */
/* Use assigning reference */
if v_addAsSynonym = 1
begin
	select distinct v_assigningRefKey = _Refs_key from MRK_History_View
		where _Marker_key = v_newKey
		and history = v_oldSymbol
		and _Marker_Event_key = 1

	/* If oldSymbol is a Riken symbol (ends with 'Rik'), then synonym type = 'similar' */
	/* else synonym type = 'exact' */


	if charindex('Rik', v_oldSymbol) > 0
	begin
	    select v_synTypeKey = _SynonymType_key from MGI_SynonymType 
		where _MGIType_key = 2 
		and _Organism_key = 1
		and synonymType = 'similar'
	end
        else
	begin
	    select v_synTypeKey = _SynonymType_key from MGI_SynonymType 
		where _MGIType_key = 2 
		and _Organism_key = 1
		and synonymType = 'exact'
        end

	exec MGI_insertSynonym v_newKey, 2, v_synTypeKey, v_oldSymbol, v_assigningRefKey

	if @@error != 0
	begin
		raiserror 99999 "Could not add synonym in MRK_simpleWithdrawal"
		rollback transaction
		return
	end
end

/* Update keys from old key to new key */

exec MRK_updateKeys v_oldKey, v_newKey

if @@error != 0
begin
	raiserror 99999 "Could not update keys in MRK_mergeWithdrawal"
	rollback transaction
	return
end

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION MRK_mergeWithdrawal(int,int,int,int,int,int) TO public;

COMMENT ON FUNCTION mgd.MRK_mergeWithdrawal(int, int,int,int,int,int) IS 'process a merge withdrawal';

EOSQL

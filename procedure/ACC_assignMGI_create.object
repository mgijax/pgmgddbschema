#!/bin/sh

#
# History
#
# lec	01/18/2006
#	- TR 7182; increased prefixPart to 30
#
# lec 03/18/2003
#	- SAO
#
# lec 09/26/2001
#	- TR 2541; add "v_private" parameter
#

cd `dirname $0` && . ./Configuration

${PG_MGD_DBSCHEMADIR}/procedure/ACC_assignMGI_drop.object

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

CREATE OR REPLACE FUNCTION ACC_assignMGI (
  v_userKey int,
  v_objectKey int,
  v_mgiType acc_mgitype.name%TYPE,
  v_prefixPart varchar(30) DEFAULT 'MGI:',
  v_nextMGI int DEFAULT -1
)
RETURNS VOID AS
\$\$

/* Assign MGI or J accession number
   Allow override of J accession number
   Increment ACC_AccessionMax.maxNumericPart
*/

DECLARE
v_nextACC int;
v_mgiTypeKey int;
v_accID acc_accession.accid%TYPE;
v_preferred int = 1;
v_private int = 0;

BEGIN

v_nextACC := max(_Accession_key) + 1 FROM ACC_Accession;
v_mgiTypeKey := _MGIType_key FROM ACC_MGIType WHERE name = v_mgiType;

IF v_nextMGI = -1
THEN
	SELECT INTO v_nextMGI maxNumericPart + 1
	FROM ACC_AccessionMax WHERE prefixPart = v_prefixPart;
ELSIF v_prefixPart != 'J:'
THEN
    RAISE EXCEPTION E'Cannot override generation of MGI accession number';
    RETURN;
END IF;

v_accID := v_prefixPart || v_nextMGI::char(30);

INSERT INTO ACC_Accession 
(_Accession_key, accID, prefixPart, numericPart, 
_LogicalDB_key, _Object_key, _MGIType_key, preferred, private, 
_CreatedBy_key, _ModifiedBy_key)
VALUES(v_nextACC, v_accID, v_prefixPart, v_nextMGI, 1, v_objectKey, 
v_mgiTypeKey, v_preferred, v_private, v_userKey, v_userKey);

IF (SELECT maxNumericPart FROM ACC_AccessionMax
    WHERE prefixPart = v_prefixPart) <= v_nextMGI
THEN
	UPDATE ACC_AccessionMax 
	SET maxNumericPart = v_nextMGI 
	WHERE prefixPart = v_prefixPart;
END IF;

RETURN;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION ACC_assignMGI(int,int,varchar,varchar,int) TO public;

COMMENT ON FUNCTION mgd.ACC_assignMGI(int,int,varchar,varchar,int) IS 'creates a new MGI id in the acc_accession table';

EOSQL


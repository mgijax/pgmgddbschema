#!/bin/sh

#
# History
#
# 06/30/2004	lec
#	- TR 5998
#
# 08/26/2003	lec
#	- TR 4708
#

cd `dirname $0` && . ./Configuration

${PG_MGD_DBSCHEMADIR}/procedure/MRK_splitWithdrawal_drop.object

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0 

CREATE OR REPLACE FUNCTION MRK_splitWithdrawal (
v_userKey int,
v_oldKey int,
v_refsKey int,
v_eventReasonKey int,
v_newSymbols text -- list of new symbols separated by commas
)
RETURNS VOID AS
\$\$

--
-- In a split, none of the new symbols are expected to exist in the database */
--
-- This procedure will process a split marker withdrawal.
-- A split withdrawal is a withdrawal where there are more than
-- one "new" markers and none of the new markers exist in the database.
--
-- A split marker withdrawal requires:
--	a) the "old" marker key
--	b) a list of comma-separated new symbols (ex. "new-1,new-2,new-3")
--	c) the reference key
--
-- Other data (mapping, homology, etc.) associated with the "split" marker
-- remains with the split marker and must be manually moved to one of the
-- new markers.
--

DECLARE
v_curationStateKey int;
v_newKey int;
v_idx int;
v_oldName mrk_marker.name%TYPE;
v_newSymbol mrk_marker.symbol%TYPE;
v_withdrawnName text;

BEGIN

v_curationStateKey := _Term_key from VOC_Term where _Vocab_key = 15 and term = 'Internal';
v_withdrawnName := 'withdrawn, = ' || substring(v_newSymbols, 1, char_length(v_newSymbols) - 1);
v_newKey := max(_Marker_key) + 1 from MRK_Marker;

v_oldName := (
	SELECT name
	FROM MRK_Marker 
	WHERE _Marker_key = v_oldKey
     	AND _Organism_key = 1
     	AND _Marker_Status_key in (1,3)
	)
	;

IF v_oldName IS NULL
THEN
	RAISE EXCEPTION E'Invalid Old Symbol Key %', v_oldKey;
	RETURN;
END IF;

--
-- For each new marker:
--
--	a.  add the new marker record
--	a.  transfer the offset values of the old marker to the new marker
--	b.  set the new key as one of the current keys of the old symbol
--	c.  copy the old symbol's history to the new marker
--	d.  insert the assignment history line for the new marker
--

LOOP
	IF v_newSymbols IS NULL
	THEN
		EXIT;
	END IF;

	--v_idx := charindex(",", v_newSymbols);
	v_idx := (select max(array_length(regexp_split_to_array(v_newSymbols, E','),1)));

	IF v_idx > 0
	THEN
		v_newSymbol := substring(v_newSymbols, 1, v_idx - 1);
		v_newSymbols := substring(v_newSymbols, v_idx + 1, char_length(v_newSymbols));
	ELSE
		-- at end of list of v_newSymbols
		v_newSymbol := v_newSymbols;
		v_newSymbols := null;
	END IF;

	IF v_newSymbol IS NOT NULL
	THEN
		-- during a split, each new marker is created and gets a new MGI accession number
		-- the original MGI accession number stays associated with the split marker

		INSERT INTO MRK_Marker 
		(_Marker_key, _Organism_key, _Marker_Type_key, _Marker_Status_key, _CurationState_key, 
			symbol, name, chromosome, _CreatedBy_key, _ModifiedBy_key)
		SELECT v_newKey, _Organism_key, _Marker_Type_key, _Marker_Status_key, v_curationStateKey, 
			v_newSymbol, name, chromosome, v_userKey, v_userKey
		FROM MRK_Marker
		WHERE _Marker_key = v_oldKey
		;

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not add marker %', v_newSymbol;
			RETURN;
		END IF;

		PERFORM ACC_assignMGI (v_userKey, v_newKey, 'Marker');

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not create marker accession ID %', v_newSymbol;
			RETURN;
		END IF;

		-- create MGD offset record for new Marker.

		INSERT INTO MRK_Offset
		(_Marker_key, source, cmoffset, creation_date, modification_date)
		SELECT v_newKey, source, cmoffset, current_date, current_date
		FROM MRK_Offset
		WHERE _Marker_key = v_oldKey and source = 0
		;

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not add marker offset';
			RETURN;
		END IF;

		-- update Marker offsets of new symbol

		PERFORM MRK_updateOffset (v_oldKey, v_newKey);

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not update marker offsets';
			RETURN;
		END IF;

		-- Update the MRK_Current record where the Current key = Old Key

		IF EXISTS (SELECT 1 FROM MRK_Current WHERE _Marker_key = v_oldKey
			AND _Current_key = v_oldKey)
		THEN
			UPDATE MRK_Current 
			SET _Current_key = v_newKey 
			WHERE _Marker_key = v_oldKey AND _Current_key = v_oldKey
			;

		-- Else, insert a new MRK_Current record

		ELSE
			INSERT INTO MRK_Current 
			VALUES (v_newKey, v_oldKey, current_date, current_date)
			;

			IF NOT FOUND
			THEN
				RAISE EXCEPTION E'MRK_splitWithdrawal: Could not add current marker';
				RETURN;
			END IF;
		END IF;

		PERFORM MRK_copyHistory (v_userKey, v_oldKey, v_newKey);

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: "Could not copy history';
			RETURN;
		END IF;

		PERFORM MRK_insertHistory (v_userKey, v_newKey, v_oldKey, v_refsKey, 5, v_eventReasonKey, v_oldName);

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not insert history';
			RETURN;
		END IF;

		-- Add History line for assignment
		PERFORM MRK_insertHistory (v_userKey, v_newKey, v_newKey, v_refsKey, 1, v_eventReasonKey, v_oldName);

		IF NOT FOUND
		THEN
			RAISE EXCEPTION E'MRK_splitWithdrawal: Could not insert history';
			RETURN;
		END IF;
	END IF;
END LOOP;

-- Now make the final necessary modifications to the old symbol

UPDATE MRK_Offset 
SET cmoffset = -999.0 
WHERE _Marker_key = v_oldKey 
AND source = 0
;

IF NOT FOUND
THEN
	RAISE EXCEPTION E'MRK_splitWithdrawal: Could not update marker offset';
	RETURN;
END IF;

DELETE FROM MRK_Offset WHERE _Marker_key = v_oldKey and source > 0;

IF NOT FOUND
THEN
	RAISE EXCEPTION E'MRK_splitWithdrawal: Could not delete marker offsets';
	RETURN;
END IF;

UPDATE MRK_Marker
SET name = v_withdrawnName, 
	cytogeneticOffset = null, 
	_Marker_Status_key = 2, 
	_ModifiedBy_key = v_userKey,
	modification_date = current_date
WHERE _Marker_key = v_oldKey
;

IF NOT FOUND
THEN
	RAISE EXCEPTION E'MRK_splitWithdrawal: Could not update marker';
	RETURN;
END IF;

DELETE FROM MRK_History WHERE _Marker_key = v_oldKey;

IF NOT FOUND
THEN
	RAISE EXCEPTION E'MRK_splitWithdrawal: Could not delete obsolete history';
	RETURN;
END IF;

RETURN;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION MRK_splitWithdrawal(int,int,int,int,text) TO public;

COMMENT ON FUNCTION mgd.MRK_splitWithdrawal(int,int,int,int,text) IS 'process a split withdrawal';

EOSQL


#!/bin/sh

#
# History
#
# lec 01/24/2008
#	- TR8216, fix selection of "toAdd" table
#

cd `dirname $0` && . ./Configuration

${PG_MGD_DBSCHEMADIR}/procedure/VOC_processAnnotHeaderAll_drop.object

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

CREATE OR REPLACE FUNCTION VOC_processAnnotHeaderAll (
v_annotTypeKey int
)
RETURNS VOID AS
\$\$

DECLARE
userKey int;
headerLabel int;
headerKey int;
pkey int;
objectKey int;
oldSeq int;	-- current sequence number
newSeq int;	-- new sequence number
prevObjectKey int;
rec record;

BEGIN

-- incrementally update VOC_AnnotHeader by annotation type

userKey := _User_key FROM MGI_User WHERE login = current_user;
headerLabel := _Label_key FROM DAG_Label WHERE label = 'Header';
headerKey := max(_AnnotHeader_key) FROM VOC_AnnotHeader;

IF headerKey = null
THEN
	headerKey := 1000;
END IF;

-- set of 'new' headers based on most recent annotation update 
-- need to check if any ancestors are header terms
-- AND if the annotated term is itself a header term 

CREATE TEMP TABLE set0 ON COMMIT DROP 
AS SELECT DISTINCT a._Object_key, h._Term_key, h.sequenceNum, a._Qualifier_key, isNormal = 0
FROM VOC_Annot a, VOC_Term t, VOC_VocabDAG vd, DAG_Node d, DAG_Closure dc, DAG_Node dh, VOC_Term h
WHERE a._AnnotType_key = v_annotTypeKey
AND a._Term_key = t._Term_key
AND t._Vocab_key = vd._Vocab_key
AND vd._DAG_key = d._DAG_key
AND t._Term_key = d._Object_key
AND d._Node_key = dc._Descendent_key
AND dc._Ancestor_key = dh._Node_key
AND dh._Label_key = headerLabel
AND dh._Object_key = h._Term_key
UNION
SELECT DISTINCT a._Object_key, h._Term_key, h.sequenceNum, a._Qualifier_key, isNormal = 0
FROM VOC_Annot a, VOC_Term t, VOC_VocabDAG vd, DAG_Node d, DAG_Closure dc, DAG_Node dh, VOC_Term h
WHERE a._AnnotType_key = v_annotTypeKey
AND a._Term_key = t._Term_key
AND t._Vocab_key = vd._Vocab_key
AND vd._DAG_key = d._DAG_key
AND t._Term_key = d._Object_key
AND d._Node_key = dc._Descendent_key
AND dc._Descendent_key = dh._Node_key
AND dh._Label_key = headerLabel
AND dh._Object_key = h._Term_key
order by a._Object_key, h.sequenceNum
;

CREATE INDEX set0_idx1 ON set0(_Term_key);

CREATE INDEX set0_idx2 ON set0(_Object_key);

CREATE INDEX set0_idx3 ON set0(_Qualifier_key);

/* set isNormal */
/* isNormal = 1 if all of the qualifiers for a given header term = 2181424 */
/* else isNormal = 0 */
CREATE TEMP TABLE normal ON COMMAND DROP
AS SELECT DISTINCT _Object_key, _Term_key
FROM set0 s1
WHERE s1._Qualifier_key = 2181424
AND NOT EXISTS (SELECT 1 FROM set0 s2
WHERE s1._Object_key = s2._Object_key
AND s1._Term_key = s2._Term_key
AND s2._Qualifier_key != 2181424)
;

UPDATE set0
SET isNormal = 1
FROM normal n
WHERE n._Object_key = set0._Object_key
AND n._Term_key = set0._Term_key
;

/* now SELECT the DISTINCT headers */
CREATE TEMP TABLE set1 ON COMMAND DROP
AS SELECT DISTINCT _Object_key, _Term_key, sequenceNum, isNormal
FROM set0
;

CREATE INDEX set1_idx1 ON set1(_Term_key);

CREATE INDEX set1_idx2 ON set1(_Object_key);

/* set of headers that are currently cached */
CREATE TEMP TABLE set2 ON COMMAND DROP
AS SELECT _AnnotHeader_key, _Object_key, _Term_key, sequenceNum, isNormal
FROM VOC_AnnotHeader
WHERE _AnnotType_key = v_annotTypeKey
order by _Object_key, sequenceNum
;

CREATE INDEX set2_idx1 ON set2(_Term_key);
CREATE INDEX set2_idx2 ON set2(_Object_key);

/* any headers in set2 that is not in set1 are deleted */
CREATE TEMP TABLE toDelete ON COMMAND DROP
AS SELECT s2._AnnotHeader_key 
FROM set2 s2
WHERE not EXISTS
(SELECT 1 FROM set1 s1 WHERE s2._Term_key = s1._Term_key AND s2._Object_key = s1._Object_key)
;

CREATE INDEX toDelete_idx1 ON toDelete(_AnnotHeader_key);

delete FROM VOC_AnnotHeader
using toDelete d
WHERE d._AnnotHeader_key = VOC_AnnotHeader._AnnotHeader_key
;

/* set of headers that are currently cached after deletion */
CREATE TEMP TABLE set3 ON COMMAND DROP
AS SELECT _Object_key, _Term_key, sequenceNum
FROM VOC_AnnotHeader
WHERE _AnnotType_key = v_annotTypeKey
order by _Object_key, sequenceNum
;

CREATE INDEX set3_idx1 ON set3(_Term_key);
CREATE INDEX set3_idx2 ON set3(_Object_key);

/* any headers in set1 that are not in set3 are added */
CREATE TEMP TABLE toAdd ON COMMAND DROP
AS SELECT row_number() over() ON COMMAND DROP
FROM set1 s1
WHERE not EXISTS (SELECT 1 FROM set3 s3 WHERE s1._Term_key = s3._Term_key AND s1._Object_key = s3._Object_key)
order by s1._Object_key, s1.sequenceNum
;

/* update the isNormal bit for any headers in #set1 that are in #set3 (existing headers) */
update VOC_AnnotHeader
set isNormal = s1.isNormal
FROM set1 s1, set3 s3
WHERE voc_annotheader._AnnotType_key = v_annotTypeKey
AND voc_annotheader._Object_key = s1._Object_key
AND voc_annotheader._Term_key = s1._Term_key
AND s1._Object_key = s3._Object_key
AND s1._Term_key = s3._Term_key
;

/* get the maximum sequence number for existing headers */
CREATE TEMP TABLE maxSequence ON COMMAND DROP
AS SELECT max(sequenceNum) as maxSeq, _Object_key
FROM set3
group by _Object_key
;

/* get the maximum sequence number for any new headers */
INSERT INTO maxSequence SELECT DISTINCT 0, _Object_key FROM toAdd t
WHERE not EXISTS (SELECT 1 FROM set3 s WHERE t._Object_key = s._Object_key)
;

CREATE INDEX idx1 on maxSequence(_Object_key)
;

INSERT INTO VOC_AnnotHeader
SELECT headerKey + i, v_annotTypeKey, t._Object_key, t._Term_key, m.maxSeq + i, isNormal,
userKey, userKey, NULL, NULL, current_date, current_date
FROM toAdd t, maxSequence m
WHERE t._Object_key = m._Object_key
;

/* automatically approve all annotations with one header */
CREATE TEMP TABLE toApprove ON COMMAND DROP
AS SELECT _AnnotHeader_key
FROM VOC_AnnotHeader
WHERE _AnnotType_key = v_annotTypeKey
AND _ApprovedBy_key is null
group by _Object_key having count(*) = 1
;

CREATE INDEX toApprove_idx1 ON toApprove(_AnnotHeader_key);

update VOC_AnnotHeader
set _ApprovedBy_key = userKey, approval_date = current_date
FROM toApprove t
WHERE t._AnnotHeader_key = voc_annotheader._AnnotHeader_key
;

/* automatically set all headers to non-approved if there is at least one header (by object) that is non-approved */
CREATE TEMP TABLE toNotApprove ON COMMAND DROP
AS SELECT _AnnotHeader_key
FROM VOC_AnnotHeader v1
WHERE v1._AnnotType_key = v_annotTypeKey
AND v1._ApprovedBy_key is null
AND EXISTS (SELECT 1 FROM VOC_AnnotHeader v2 WHERE v2._AnnotType_key = v_annotTypeKey
AND v1._AnnotHeader_key != v2._AnnotHeader_key
AND v1._Object_key = v2._Object_key
AND v2._ApprovedBy_key is not null)
;

CREATE INDEX toNotApprove_idx1 ON toNotApprove(_AnnotHeader_key);

update VOC_AnnotHeader
set _ApprovedBy_key = null, approval_date = null
FROM toNotApprove t
WHERE t._AnnotHeader_key = voc_annotheader._AnnotHeader_key
;

/* re-order */
prevObjectKey := -1;

FOR rec IN
SELECT _AnnotHeader_key, _Object_key, sequenceNum
FROM VOC_AnnotHeader
WHERE _AnnotType_key = v_annotTypeKey
ORDER by _Object_key, sequenceNum
LOOP

    SELECT into pkey, objectKey, oldSeq
	rec._annotheader_key, rec._object_key, rec.sequencenum;

    if objectKey != prevObjectKey
    then
	newSeq := 1;
    end if;

    update VOC_AnnotHeader set sequenceNum = newSeq WHERE _AnnotHeader_key = pkey;

    newSeq := newSeq + 1;

    prevObjectKey := objectKey;

END LOOP;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION VOC_processAnnotHeaderAll(int) TO public;

COMMENT ON FUNCTION VOC_processAnnotHeaderAll(int) IS 'incrementally update VOC_AnnotHeader by annotation type';

EOSQL

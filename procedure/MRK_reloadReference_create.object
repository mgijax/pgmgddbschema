#!/bin/sh

#
# History
#
# 03/16/2006	lec
#	- TR 7530; removed MLD_Marker
#
# 12/08/2005	lec
#	- added mgiID, jnumID, jnum, pubmedID to MRK_Reference
#
# 12/09/2004	lec
#	- TR 5686; MRK_Other replaced by MGI_Synonym
#
# lec	03/10/2004
#	- missing Allele and Annotation References
#

cd `dirname $0` && . ./Configuration

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

DROP FUNCTION MRK_reloadReference(int);

CREATE OR REPLACE FUNCTION MRK_reloadReference (
v_markerKey int
)
RETURNS VOID AS
\$\$

DECLARE
v_refKey int;
marker_cursor refcursor;

BEGIN

DELETE FROM MRK_Reference WHERE _Marker_key = v_markerKey;

OPEN marker_cursor FOR
SELECT DISTINCT m._Refs_key
FROM PRB_Marker m
WHERE m._Marker_key = v_markerKey
UNION 
SELECT DISTINCT h._Refs_key
FROM HMD_Homology_Marker hm, HMD_Homology h 
WHERE hm._Marker_key = v_markerKey
AND hm._Homology_key = h._Homology_key 
UNION 
SELECT DISTINCT h._Refs_key
FROM MRK_History h
WHERE h._Marker_key = v_markerKey
AND h._Refs_key IS NOT NULL
UNION 
SELECT DISTINCT e._Refs_key
FROM MLD_Expts e, MLD_Expt_Marker em
WHERE em._Marker_key = v_markerKey
AND em._Expt_key = e._Expt_key
UNION 
SELECT DISTINCT _Refs_key
FROM GXD_Index 
WHERE _Marker_key = v_markerKey
UNION 
SELECT DISTINCT _Refs_key
FROM GXD_Assay 
WHERE _Marker_key = v_markerKey
UNION 
SELECT DISTINCT _Refs_key
FROM MGI_Synonym
WHERE _Object_key = v_markerKey
AND _MGITYpe_key = 2
AND _Refs_key IS NOT NULL
UNION 
SELECT DISTINCT ar._Refs_key
FROM ACC_Accession a, ACC_AccessionReference ar 
WHERE a._Object_key = v_markerKey
AND a._MGIType_key = 2 
AND a.private = 0
AND a._Accession_key = ar._Accession_key 
UNION
SELECT DISTINCT r._Refs_key
FROM ALL_Allele a, MGI_Reference_Assoc r
WHERE a._Marker_key = v_markerKey
AND a._Allele_key = r._Object_key
AND r._MGIType_key = 11
UNION
SELECT DISTINCT r._Refs_key
FROM VOC_Annot a, VOC_Evidence r
WHERE a._AnnotType_key = 1000
AND a._Object_key = v_markerKey
AND a._Annot_key = r._Annot_key
UNION 
SELECT DISTINCT _Refs_key
FROM MGI_Reference_Assoc
WHERE _Object_key = v_markerKey and _MGIType_key = 2
;
LOOP
        FETCH marker_cursor INTO v_refKey;
        EXIT WHEN NOT FOUND;

	IF NOT EXISTS (select * FROM MRK_Reference WHERE _Marker_key = v_markerKey and _Refs_key = v_refKey)
	THEN
		INSERT INTO MRK_Reference (_Marker_key, _Refs_key, mgiID, jnumID, pubmedID, jnum)
		SELECT v_markerKey, v_refKey, a1.accID, a2.accID, a3.accID, a2.numericPart
		FROM ACC_Accession a1, ACC_Accession a2, ACC_Accession a3
		WHERE a1._MGIType_key = 1
		AND a1._Object_key = v_refKey
		AND a1._LogicalDB_key = 1
		AND a1.prefixPart = 'MGI:'
		AND a1.preferred = 1
		AND a2._MGIType_key = 1
		AND a1._Object_key = a2._Object_key
		AND a2._LogicalDB_key = 1
		AND a2.prefixPart = 'J:'
		AND a2.preferred = 1
		AND a1._Object_key *= a3._Object_key
		AND a3._LogicalDB_key = 29
		AND a3.preferred = 1
		;
	END IF;
END LOOP;
CLOSE marker_cursor;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION MRK_reloadReference(int) TO public;

COMMENT ON FUNCTION MRK_reloadReference(int) IS '';

EOSQL

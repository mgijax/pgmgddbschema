#!/bin/sh

cd `dirname $0` && . ./Configuration

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

--
-- NAME: ALL_Marker_Assoc_delete()
--
-- DESCRIPTOIN:
--	
-- INPUT:
--	none
--
-- RETURNS:
--	NEW
--

DROP TRIGGER IF EXISTS ALL_Marker_Assoc_delete_trigger ON ALL_Marker_Assoc;
DROP FUNCTION IF EXISTS ALL_Marker_Assoc_delete();

CREATE OR REPLACE FUNCTION ALL_Marker_Assoc_delete() RETURNS TRIGGER AS \$\$
BEGIN

/* if we are deleting a marker/allele association, then we need to set the
 * cached marker key in ALL_Allele to be null
 */

update ALL_Allele set _Marker_key = null
where _Marker_key = OLD._Marker_key
    and _Allele_key = OLD._Allele_key
;

/* also remove the marker association in various other tables */

update GXD_AlleleGenotype set _Marker_key = null
where _Marker_key = OLD._Marker_key
    and _Allele_key = OLD._Allele_key
;

update GXD_AllelePair set _Marker_key = null
where _Marker_key = OLD._Marker_key
    and (_Allele_key = OLD._Allele_key_1 or _Allele_key = OLD._Allele_key_2)
;

update MRK_OMIM_Cache set _Marker_key = null
where _Marker_key = OLD._Marker_key
    and _Allele_key = OLD._Allele_key
;

update PRB_Strain_Marker set _Marker_key = null
where _Marker_key = OLD._Marker_key
    and _Allele_key = OLD._Allele_key
;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION ALL_Marker_Assoc_delete() TO public;

CREATE TRIGGER ALL_Marker_Assoc_delete_trigger
AFTER DELETE on ALL_Marker_Assoc
FOR EACH ROW
EXECUTE PROCEDURE ALL_Marker_Assoc_delete();

COMMENT ON FUNCTION mgd.ALL_Marker_Assoc_delete() IS 'creates a delete trigger for this _Object_key/_MGIType_key table';

EOSQL

*************************************

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

--
-- NAME: ALL_Marker_Assoc_insert()
--
-- DESCRIPTOIN:
--
-- RULES:
--
-- INPUT:
--	none
--
-- RETURNS:
--	NEW
--

DROP TRIGGER IF EXISTS ALL_Marker_Assoc_insert_trigger ON ALL_Marker_Assoc;
DROP FUNCTION IF EXISTS ALL_Marker_Assoc_insert();

CREATE OR REPLACE FUNCTION ALL_Marker_Assoc_insert() RETURNS TRIGGER AS \$\$

BEGIN

update ALL_Allele
set _Marker_key = NEW._Marker_key, nomenSymbol = null
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update GXD_AlleleGenotype
set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update GXD_AllelePair
set _Marker_key = NEW._Marker_key
where (_Allele_key_1 = NEW._Allele_key or _Allele_key_2 = NEW._Allele_key)
and NEW._Status_key = 4268546
;

update MRK_OMIM_Cache
set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update PRB_Strain_Marker 
set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION ALL_Marker_Assoc_insert() TO public;

CREATE TRIGGER ALL_Marker_Assoc_insert_trigger
AFTER INSERT ON ALL_Marker_Assoc
FOR EACH ROW
EXECUTE PROCEDURE ALL_Marker_Assoc_insert();

COMMENT ON FUNCTION mgd.ALL_Marker_Assoc_insert() IS 'creates an insert trigger to call acc_assignmgi()/default values';

EOSQL

***************************************

cat - <<EOSQL | ${PG_DBUTILS}/bin/doisql.csh $0

--
-- NAME: ALL_Marker_Assoc_update()
--
-- DESCRIPTOIN:
--
-- RULES:
--
-- INPUT:
--	none
--
-- RETURNS:
--	NEW
--

DROP TRIGGER IF EXISTS ALL_Marker_Assoc_update_trigger ON ALL_Marker_Assoc;
DROP FUNCTION IF EXISTS ALL_Marker_Assoc_update();

CREATE OR REPLACE FUNCTION ALL_Marker_Assoc_update() RETURNS TRIGGER AS \$\$

BEGIN

/* if we change the allele or marker keys, then we need to invalidate the
* prior cached relationships and cache the new ones (as long as the new
* ones were not invalidated by a curator).  similar process should work
* for changes to the status key.
*/

update ALL_Allele set _Marker_key = null
where _Allele_key = NEW._Allele_key
;

update ALL_Allele set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update GXD_AlleleGenotype set _Marker_key = null
where _Allele_key = NEW._Allele_key
;

update GXD_AlleleGenotype set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update GXD_AllelePair set _Marker_key = null
where (_Allele_key_1 = NEW._Allele_key or _Allele_key_2 = NEW._Allele_key)
;

update GXD_AllelePair set _Marker_key = NEW._Marker_key
where (_Allele_key_1 = NEW._Allele_key or _Allele_key_2 = NEW._Allele_key)
and NEW._Status_key = 4268546
;

update MRK_OMIM_Cache set _Marker_key = null
where _Allele_key = NEW._Allele_key
;

update MRK_OMIM_Cache set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

update PRB_Strain_Marker set _Marker_key = null
where _Allele_key = NEW._Allele_key
;

update PRB_Strain_Marker set _Marker_key = NEW._Marker_key
where _Allele_key = NEW._Allele_key
and NEW._Status_key = 4268546
;

END;
\$\$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION ALL_Marker_Assoc_update() TO public;

CREATE TRIGGER ALL_Marker_Assoc_update_trigger
AFTER UPDATE OF _Allele_key, _Marker_key ON ALL_Marker_Assoc
FOR EACH ROW
EXECUTE PROCEDURE ALL_Marker_Assoc_update();

COMMENT ON FUNCTION mgd.ALL_Marker_Assoc_update() IS 'creates an update trigger to check some permissions';

EOSQL



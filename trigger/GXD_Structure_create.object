#!/bin/csh -f -x

#
# History
#
# 12/15/2010	lec
#	- TR10456/TR10457/add call to generate MGI ids
#
# 09/15/2009	lec
#	- TR9797/do not run triggers for multiple updates
#

cd `dirname $0` && source ./Configuration

cat - <<EOSQL | ${MGI_DBUTILS}/bin/doisql.csh ${DBSERVER} ${DBNAME} $0

use ${DBNAME}
go

create trigger GXD_Structure_Insert
on GXD_Structure
for insert
as

-- if > 1 row are affected, skip

if @@rowcount > 1
	return

/* Ensure that _Parent_key of inserted exists as a _Structure_key and
   that parent has the same _Stage_key as inserted, if _Parent_key != NULL */

if (select _Parent_key from inserted) != NULL
begin
    if not exists (select *
        from GXD_Structure s, inserted
        where inserted._Parent_key = s._Structure_key
        and inserted._Stage_key = s._Stage_key)
    begin
       rollback transaction
       raiserror 99999 "GXD_Structure_Insert: Specified parent Structure does not exist"
       return
    end
end

declare @treeDepth integer
select @treeDepth = 1  /* assume that we are adding a child of a Stage node */

/* if the assumption doesn't hold, then the following query will set the
   current child's treeDepth */ 

/* find out the depth of the parent structure */
select @treeDepth = s.treeDepth + 1
from GXD_Structure s, inserted
where s._Structure_key = inserted._Parent_key 

/* update the inserted node */
update GXD_Structure
set treeDepth = @treeDepth
from GXD_Structure s, inserted
where s._Structure_key = inserted._Structure_key

if @@error != 0
begin
  rollback transaction
  raiserror 99999 "GXD_Structure_Insert: Update of treeDepth failed"
  return
end

/* incrementally modify the closure */

declare @inp integer  /* inserted node's parent */
select @inp = _Parent_key from inserted

/* _Parent_key will be null for an immediate child of a stage root,
   this node, by definition will not have any entries in the closure table,
   since it is a root node as far as the database is concerned */ 

if @inp != NULL
begin
   
   declare ancest_cursor cursor
   for select c._Structure_key
       from GXD_StructureClosure c
       where c._Descendent_key = @inp
   
   declare @sk integer
   declare @isk integer
   select @isk = _Structure_key from inserted  
   
   open ancest_cursor
   fetch ancest_cursor into @sk
   while (@@sqlstatus = 0)
   begin
      /* for each ancestor, insert ancestor's _Structure_key, inserted's 
         _Structure_key in GXD_StructureClosure */ 
      insert into GXD_StructureClosure (_Structure_key, _Descendent_key) 
             values (@sk, @isk)
      if @@error != 0
      begin
         rollback transaction
         raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
         close ancest_cursor
         return
      end
      fetch ancest_cursor into @sk
   end
   close ancest_cursor
   
   /* finally, insert the inserted node's _Parent_key and the inserted node's
      _Structure_key into the closure table */
   
   insert into GXD_StructureClosure (_Structure_key, _Descendent_key)
       values (@inp, @isk)
   if @@error != 0
   begin
      rollback transaction
      raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
      return
   end
end

declare @key integer
select @key = _Structure_key from inserted
exec ACC_assignMGI @key, "GXD Structures"

if (@@error != 0)
begin
        rollback transaction
        return
end

/* Do not compute the printName for the inserted structure here!
   this will be taken care of by the GXD_StructureName triggers.
   The name records must be in place before a printName recomputation
   can be done. */ 



go

create trigger GXD_Structure_Update
on GXD_Structure
for update
as

-- if > 1 row are affected, skip

if @@rowcount > 1
	return

   /* make certain that printStop bits don't get cleared on Structures
      that are children of the Stage root nodes */

   if exists (select printStop 
              from inserted
              where printStop = 0 
              and _Parent_key = NULL)
   begin
        rollback transaction
        raiserror 99999 "GXD_Structure_Update: Cannot clear printStop on child of stage root"
        return
   end

   /* recalculate printnames on those structures where printStop has
      been changed */
 
   declare pstop_cursor cursor
   for select inserted._Structure_key
       from deleted, inserted
       where deleted.printStop != inserted.printStop
       and deleted._Structure_key = inserted._Structure_key
 
   declare @sk integer
   open pstop_cursor
   fetch pstop_cursor into @sk
   while (@@sqlstatus = 0)
   begin
       exec GXD_ComputePrintNamesFrom @sk
       if @@error != 0
       begin
           rollback transaction
           raiserror 99999 "GXD_Structure_Update: GXD_ComputePrintNamesFrom fail
ed"
           close pstop_cursor
           return
       end
       fetch pstop_cursor into @sk
   end
   close pstop_cursor


go

create trigger GXD_Structure_Delete
on GXD_Structure
for delete
as

-- if > 1 row are affected, skip

if @@rowcount > 1
	return

/* Disallow deletion if record is not an MGI-added record, but
   only if the user does not have the sa_role */

if exists (select * from deleted where edinburghkey != NULL)
begin
	if (select proc_role("sa_role")) != 1
        begin
           rollback transaction
           raiserror 99999 "GXD_Structure_Delete: Structure is not an MGI-added record"
	       return
        end
end

/* Disallow deletion if record is not a leaf node, i.e. it has descendents */

if exists (select * from GXD_StructureClosure, deleted
    where GXD_StructureClosure._Structure_key = deleted._Structure_key)
begin
        rollback transaction
        raiserror 99999 "GXD_Structure_Delete: Structure is not a leaf node; it has descendents"
        return
end

/* Disallow deletion if record is referenced elsewhere */

if exists (select * from GXD_ISResultStructure, deleted
    where GXD_ISResultStructure._Structure_key = deleted._Structure_key)
begin
        rollback transaction
        raiserror 99999 "GXD_Structure_Delete: Structure is referenced in InSitu Result Record(s)"
        return
end
 
if exists (select * from GXD_GelLaneStructure, deleted
    where GXD_GelLaneStructure._Structure_key = deleted._Structure_key)
begin
        rollback transaction
        raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Gel Lane Structure Record(s)"
        return
end

if exists (select * from GXD_Expression, deleted
    where GXD_Expression._Structure_key = deleted._Structure_key)
begin
        rollback transaction
        raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Expression Results (cache) Record(s)"
	    return
end

/* incrementally modify the closure */
delete GXD_StructureClosure 
from GXD_StructureClosure sc, deleted
where sc._Descendent_key = deleted._Structure_key

if @@error != 0
begin
    rollback transaction
    raiserror 99999 "GXD_Structure_Delete: Delete of closure records failed"
    return
end

/* cascade deletes into the StructureName table */
delete GXD_StructureName
from GXD_StructureName sn, deleted
where sn._Structure_key = deleted._Structure_key

if @@error != 0
begin
    rollback transaction
    raiserror 99999 "GXD_Structure_Delete: Cascaded delete of StructureNames failed"
    return
end

delete ACC_Accession from ACC_Accession a, deleted d
where a._Object_key = d._Structure_key and a._MGIType_key = 38

if @@error != 0
begin
    rollback transaction
    raiserror 99999 "GXD_Structure_Delete: Delete of accession ids failed"
    return
end

go

checkpoint
go

quit

EOSQL
